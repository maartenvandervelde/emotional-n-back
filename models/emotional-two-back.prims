//---------------------------
// Model of an emotional 2-back task using a reference strategy:
//
// Items are pushed to declarative memory as soon as possible.
// A retrieval cue to the most recently seen item in memory is kept in working memory.
// Previously seen items are chained together using retrieval cues, so that increasingly distant items can be recalled.
//
// This model requires a custom version of the PRIMs cognitive architecture to run: https://github.com/maartenvandervelde/ACTransfer
//
// Copyright Maarten van der Velde
//
//---------------------------


define task emotional-two-back {
	
	task-constants: (target face happy sad neutral same diff start fixation memory face-observation, process-face get-one-back get-two-back respond update)
	
	initial-goals: (do-two-back wander)
	goals: ()
	
	default-activation: 1.0 // lower bound on baselevel activation (default: none)
	imaginal-activation: 0.25 // spreading activation from WM (default 0.0). A value of 0.25 gives it equal strength to goal buffer spreading
	
	// retrieval-reinforces: t // every time a fact is retrieved from DM, it receives an extra reference (default: nil -- but t in ACT-R)
	
	pm: t // partial matching		
}



define goal do-two-back {
	
	// Processing the current stimulus

 	operator process-face {
 		"If a face is perceived, recognise its expression (approximated via a DM retrieval)"
 		V1 = face
 		V2 <> nil
 		V3 = nil
		G3 = nil
 		==>
 		face-expression -> RT1
 		V2 -> RT3
		process-face -> G3
 	}
	
	operator recognise-face {
		"The expression of the current face has been retrieved. Place it in WM."
		RT1 = face-expression
		G3 = process-face
		==>
		face-observation -> WM1
		ASSIGN_NEW_CONTEXT_LABEL -> WM2
		RT2 -> WM3
		get-one-back -> G3
	}
	
	
	
	// Responding
	
	operator no-one-back {
		"There is no previous face expression, so don't answer"
		WM1 = face-observation
		WM4 = nil
		G3 = get-one-back
		==>
		update -> G3
	}
	
	operator retrieve-one-back {
		"Try to retrieve the previous face expression in the current sequence"
		WM1 = face-observation
		WM4 <> nil	// WM4 contains the context label for the 1-back face
		G3 = get-one-back
		==>
		face-observation -> RT1
		WM4 -> RT2
		get-two-back -> G3
	}
	
	operator failed-to-retrieve-one-back {
		"1-back retrieval was unsuccessful, so don't respond"
		RT1 = error
		G3 = get-two-back
		==>
		update -> G3
	}
	
	operator retrieve-two-back {
		"Upon successful retrieval of the previous expression, try to retrieve the 2-back expression in the current sequence"
		RT1 = face-observation
		// RT2 = WM4	// Check that this is the 1-back face
		RT4 <> nil	// There is a retrieval cue for the 2-back face
		G3 = get-two-back
		==>
		face-observation -> RT1
		RT4 -> RT2	// RT4 contains the context label for the 2-back face
		respond -> G3
	}
	
	operator cannot-retrieve-two-back {
		"1-back retrieval was successful, but the 1-back contains no retrieval cue for the 2-back, so don't respond"
		RT1 = face-observation
		// RT2 = WM4	// Check that this is the 1-back face
		RT4 = nil	// There is no retrieval cue for the 2-back face
		G3 = get-two-back
		==>
		update -> G3
	}
	
	operator failed-to-retrieve-two-back {
		"2-back retrieval was unsuccessful, so don't respond"
		RT1 = error
		G3 = respond
		==>
		update -> G3
	}
	
	operator two-back-match-press-same {
		"The 2-back expression matches the expression of the current face"
		RT1 = face-observation
		// RT2 <> WM4	// Check that this is not the 1-back face
		RT3 = WM3
		G3 = respond
		==>
 		press-key -> AC1
 		same -> AC2
		update -> G3
	}
	
	operator two-back-no-match-press-diff {
		"The 2-back expression does not match the expression of the current face"
		RT1 = face-observation
		// RT2 <> WM4	// Check that this is not the 1-back face
		RT3 <> WM3
		G3 = respond
		==>
 		press-key -> AC1
 		diff -> AC2
		update -> G3
	}

	
	
	
	// Updating
	
	operator update-one-back-cue {
		"Push the current chunk in WM (containing mood and possibly 1-back cue) to DM. Create a new chunk with 1-back cue"
		G3 = update
		==>
		nil -> WM1
		nil -> WM2
		nil -> WM3
		WM2 -> WM4
		nil -> G3
	}
	
	
	
	// Rehearsal
	
	operator rehearse-one-back {
		"If there is time left in the trial, rehearse the two most recent items, starting with 1-back"
		V3 = done
		WM4 <> nil
		G3 = nil
		==>
		face-observation -> RT1
		WM4 -> RT2
	}
	
	operator rehearse-two-back {
		"Upon retrieving the 1-back for retrieval, use its cue to retrieve the 2-back"
		V3 = done
		RT1 = face-observation
		RT4 <> nil
		G3 = nil
		==>
		face-observation -> RT1
		RT4 -> RT2
	}

}



define goal wander {
	
	operator ignore-face-wander-instead {
		"Start mind-wandering when a face stimulus appears"
		V1 = face
		V2 <> nil
		V3 = nil
		==>
		memory -> RT1
		self -> RT2
		nil -> G3
	}
	
	operator ignore-responding-wander-instead {
		"Start mind-wandering when a facial expression has been retrieved"
		RT1 = face-expression
		==>
		memory -> RT1
		self -> RT2
		nil -> G3
	}
	
	operator ignore-nback-wander-instead {
		"Start mind-wandering when a previous face observation has been retrieved"
		RT1 = face-observation
		==>
		memory -> RT1
		self -> RT2
		nil -> G3
	}
	
	operator done-retrieve-random-memory {
		"When there is nothing left to do, retrieve a random memory"
		V3 = done
		==>
		memory -> RT1
		self -> RT2
		nil -> G3
	}
	
	operator process-memory {
		"When a random memory has been retrieved, place it in WM"
		RT1 = memory
		==>
		RT4 -> WM1
	}
}

define facts {		
	(memory x y) // Explicit definition prevents unwanted retrievals of "memory" chunk during mind-wandering
}


define action press-key {
  latency: 0.3
  noise: 0.1
  distribution: uniform
  output: Pressing
}


define script {	
	
	// The 2-back task consists of 6 blocks of 55 trials each (plus 10 practice trials).
	// In each trial a face is shown. The participant has to indicate whether the face's expression matches that of the face two trials ago.
	// Images are presented for 2 seconds. There is an inter-trial interval of 2.5 seconds.
		
	/////////////
	/// SETUP ///
	/////////////

	verbose = 1 // Set to 1 to get more verbose output (required for parsing batch runs)
	
	// Create 46 stimuli of each expression
	happy-faces = []
	neutral-faces = []
	sad-faces = []
	
	for i in 0 to 45 {
		happy-faces[i] = ["happy", "happy" + i]
		neutral-faces[i] = ["neutral", "neutral" + i]
		sad-faces[i] = ["sad", "sad" + i]	
	}
	
	// Combine all stimuli in a single list
	all-faces = []
	for i in 0 to 45 {
		// all-faces[i] = ["happy", happy-faces[i]]
		// all-faces[i + 46] = ["neutral", neutral-faces[i]]
		// all-faces[i + 92] = ["sad", sad-faces[i]]
		all-faces[i] = happy-faces[i]		
		all-faces[i + 46] = neutral-faces[i]
		all-faces[i + 92] = sad-faces[i]	
	}
	
	// Add all faces to the model's DM (this allows it to recognise facial expressions)
	for i in 0 to 137 {
		face = all-faces[i]
		chunk-name = "face" + i
		expression = face[0]
		image = face[1]
		add-dm(chunk-name, "face-expression", expression, image)
		
		// 3/10/2017: set strength of association between mood chunks and face chunks to a positive value rather than 0
		// to allow spreading activation from the target (goal buffer) to similar chunks in memory
		sji_mood_to_face = 1 // in practice the actual SA is 1/4 of this value (since there are 4 slots in the goal buffer)
	
	
		// set activation of face depending on its mood
		face_activation_happy = 1
		face_activation_neutral = 0.75
		face_activation_sad = 1
	
		if (expression == "happy") {
			set-activation(chunk-name, face_activation_happy)
			set-sji("happy", chunk-name, sji_mood_to_face)
		}
	
		if (expression == "neutral") {
			set-activation(chunk-name, face_activation_neutral)
			set-sji("neutral", chunk-name, sji_mood_to_face)
		}
	
		if (expression == "sad") {
			set-activation(chunk-name, face_activation_sad)
			set-sji("sad", chunk-name, sji_mood_to_face)
		}
	}
		
	
	all-faces = shuffle(all-faces)
		
	// The experiment has 330 trials, 110 per facial expression.
	// Add 64 items to each expression through duplication
	happy-faces-dupl = []
	neutral-faces-dupl = []
	sad-faces-dupl = []
	
	for i in 0 to 45 {
		happy-faces-dupl[i] = happy-faces[i] // include original 46 faces 
		neutral-faces-dupl[i] = neutral-faces[i]
		sad-faces-dupl[i] = sad-faces[i]
		happy-faces-dupl[i + 46] = happy-faces[i] // include original 46 faces a second time
		neutral-faces-dupl[i + 46] = neutral-faces[i]
		sad-faces-dupl[i + 46] = sad-faces[i]
		if (i < 18) {
			happy-faces-dupl[i + 92] = happy-faces[i] // include 18 faces a third time
			neutral-faces-dupl[i + 92] = neutral-faces[i]
			sad-faces-dupl[i + 92] = sad-faces[i]
		}
	}
	
	task-stimuli = []
	
	for i in 0 to 109 {
		task-stimuli[i] = happy-faces-dupl[i]
		task-stimuli[i + 110] = neutral-faces-dupl[i]
		task-stimuli[i + 220] = sad-faces-dupl[i]
	}
	
	task-stimuli = shuffle(task-stimuli)
	
	
	// There are 6 blocks of 55 trials
	blocks = []
	
	block1 = []
	block2 = []
	block3 = []
	block4 = []
	block5 = []
	block6 = []
	
	// Put 55 trials in each of the six blocks
	// Trials are drawn randomly from the complete list
	for i in 0 to 54 {
		block1[i] = task-stimuli[i]
		block2[i] = task-stimuli[i + 55]
		block3[i] = task-stimuli[i + 110]
		block4[i] = task-stimuli[i + 165]
		block5[i] = task-stimuli[i + 220]
		block6[i] = task-stimuli[i + 275]
	}
	
	blocks[0] = block1
	blocks[1] = block2
	blocks[2] = block3
	blocks[3] = block4
	blocks[4] = block5
	blocks[5] = block6
	
	if (verbose) {
		print("Setting up 2-back task...")
		print("Randomly created 6 blocks of trials:")
		blocknum = 1
		for block in blocks {
			print()
			print("BLOCK ", blocknum)
			blocknum = blocknum + 1
			print("______________________________________")
			print("EXPRESSION        FACE")
			print("______________________________________")
			trialnum = 0
			expressions = [0, 0, 0]
			expr = ""
			for trial in block {
				expression = trial[0]
				face = trial[1]
				if (expression == "happy") {
					expressions[0] = expressions[0] + 1
					expr = "hap"
				}
				if (expression == "neutral") {
					expressions[1] = expressions[1] + 1
					expr = "neu"
				}
				if (expression == "sad") {
					expressions[2] = expressions[2] + 1
					expr = "sad"
				}
				print(expr, "                        ", face)
				
				trialnum = trialnum + 1
			}
			print("______________________________________")
			print("(", trialnum, "trials. Happy:", expressions[0], " Neutral:", expressions[1], " Sad:", expressions[2], ")")
			print("______________________________________")
		}
	}
	
	
	// Create off-task memories
	// Slots:
	// title (e.g. memoryhappy1): for convenience.
	// memory: indicates chunk type; used as first retrieval cue.
	// self: used as an additional retrieval cue (without it we get weird retrievals of random singletons due to partial matching).
	// name (e.g. ha1): distinguishes one happy memory from another (i.e. the specific content).
	// mood (e.g. happy): describes mood of the memory. This part of the memory is placed in WM to spread activation.
	
	// Strength of association between mood chunks and corresponding memory chunks
	sji_mood_to_memory = 1
	
	for i in 0 to 10 {
		memoryhappy = "memoryhappy" + i
		name = "ha" + i
		add-dm(memoryhappy, "memory", "self", name, "happy")
		set-sji("happy", memoryhappy, sji_mood_to_memory)
		
		memoryneutral = "memoryneutral" + i
		name = "ne" + i
		add-dm(memoryneutral, "memory", "self", name, "neutral")
		set-sji("neutral", memoryneutral, sji_mood_to_memory)
		
		memorysad = "memorysad" + i
		name = "sa" + i
		add-dm(memorysad, "memory", "self", name, "sad")
		set-sji("sad", memorysad, sji_mood_to_memory)
	}
	
	
	
	// Set goal activation
	set-activation("do-two-back", 5)
	set-activation("wander", 1)
	
	// Set mood activation
	set-activation("happy", 3)
	set-activation("neutral", 3)
	set-activation("sad", 3)
	
	
	
	
	// Set activation of process-face operator so high that it can break through mind-wandering
	set-activation("process-face", 1.5)
	
	
	
	
	//////////////////////
	/// RUN EXPERIMENT ///
	//////////////////////
	
	if (verbose) {
		print()
		print("Running experiment...")
	}

	// The experiment consists of 3 blocks
	blocknum = 0
	for block in blocks {
		
		blocknum = blocknum + 1
		
		if (verbose) {
			print("______________________________________")
			print("Starting block", blocknum)
			print("______________________________________")
		}
		
		// Each block contains 55 trials
		trialnum = 0
		for trial in block {
			trialnum = trialnum + 1
			expression = trial[0]
			face = trial[1]
			response = "none"
			
			starttime = time()
			
			if (verbose) {
				print("______________________________________")
				print("Trial", trialnum, "expression:", expression, "time:", time())
				print("______________________________________")
			}
				
			// show face stimulus					
			screen("face", face)
			
			// The face stimulus is on screen for 2.0 seconds
			run-until-relative-time-or-action(2.0, "press-key")
			rt = time() - starttime
			timeleft = 2.0 - rt
			if (verbose) {
				print("----- TIME LEFT: ", timeleft)
			}
			
			
			// Retrieve the model's latest action (which contains its response or lack thereof)
			action = last-action()
			if (length(action) > 1) {
				response = action[1]				
			}
			if (verbose) {
				print("Action:", response)
			}
			
			// If the model was done running before the 2 seconds were up, it responded on time
			if (timeleft > 0) {
				
				// Show "done" on the screen so that the model does not respond again
				screen("face", face, "done")
				
				// Run the model for the remainder of the two seconds
				run-relative-time(timeleft)
			
			} else {
				// The model did not respond within 2 seconds
				if (verbose) {
					print("No response within 2s time limit.")
				}
			}
			
			// There is a 0.5 second interval between trials, in which the screen is empty (here fixation)
			screen("fixation")

			run-relative-time(0.5)
		}
	
	}

}